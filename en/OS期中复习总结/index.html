<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-xxxxxx-xx');
    </script>
  

  <!-- Baidu Tongji -->
  
    <script type="text/javascript">
      // Originial
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  <!-- Baidu Push -->
  
    <script>
      (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
      })();
    </script>
  

  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc"/>
  <meta name="baidu-site-verification" content="PpzM9WxOJU"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="It&#39;s a private blog about a human being, welcome to subscribe!"/>
  <meta name="keyword" content="Learning,living,gaming"/>
  <link rel="shortcut icon" href="/img/avatar/roguerabbit.jpg"/>

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/beantech.min.css"/>

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css"/>
    <link rel="stylesheet" href="/css/widget.css"/>
    <link rel="stylesheet" href="/css/rocket.css"/>
    <link rel="stylesheet" href="/css/signature.css"/>
    <link rel="stylesheet" href="/css/catalog.css"/>
    <link rel="stylesheet" href="/css/livemylife.css"/>

    
      <!-- wave start -->
      <link rel="stylesheet" href="/css/wave.css"/>
      <!-- wave end -->
    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="/css/top.css"/>
      <!-- top end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/scroll.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="/css/viewer.min.css"/>
      <!-- viewer end -->
    

    
      <!-- Search start -->
      <link rel="stylesheet" href="/css/search.css"/>
      <!-- Search end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="/css/themecolor.css"/>
      <!-- ThemeColor end -->
    

    

    
      <!-- gitalk start -->
      <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> -->
      <link rel="stylesheet" href="/css/gitalk.css"/>
      <!-- gitalk end -->
    
  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="http://s7am1na.github.io/en/OS期中复习总结/">
  <title>
    
      OS期中复习总结 - just a private corner
    
  </title>
<meta name="generator" content="Hexo 5.4.2"></head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--dark">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'dark';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		
		<!-- Gitter -->
<!-- Docs:https://gitter.im/?utm_source=left-menu-logo -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'your-community/your-room'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">
        S7的温柔时空角
      </a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">
              HOME
            </a>
          </li>

          
            
              <li>
                <a href="/about/">
                  
                        ABOUT
                          
                                    
                </a>
              </li>
              
                
            
                
            
              <li>
                <a href="/categories/">
                  
                            CATEGORIES
                              
                                    
                </a>
              </li>
              
                
            
              <li>
                <a href="/archive/">
                  
                    ARCHIVES
                      
                                    
                </a>
              </li>
              
                
            
              <li>
                <a href="/tags/">
                  
                                TAGS
                                  
                                    
                </a>
              </li>
              
                

                  
                    <li>
                      <a class="popup-trigger">
                        <span class="search-icon"></span>
                        SEARCH
                      </a>
                    </li>
                    

                      <!-- LangSelect -->
                      
                        
                          
                                
                                      
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function () {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>

		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('/img/header_img/categories_bg.WebP');
      --intro-header-background-image-url-post: url('/img/header_img/ghost_blade4.jpg');
      --intro-header-background-image-url-page: url('//img/header_img/ghost_blade4.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/categories_bg.WebP');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('/img/header_img/ghost_blade4.jpg');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('//img/header_img/ghost_blade4.jpg');
    }

    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url('/img/header_img/ghost_blade4.jpg'); */
      
    }

    
  </style>





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#OS" title="OS">OS</a>
              
            </div>
            <h1>OS期中复习总结</h1>
            <h2 class="subheading">WARNING: OS MID-TERM EXAM!!!</h2>
            <span class="meta">
              Posted by John Doe on
              2025-04-20
            </span>


            
            <!-- WordCount start -->
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">47</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">13.3k</span> In Total
            </span>
            <div class="blank_box"></div>
            <!-- WordCount end -->
            
            
            <!-- 不蒜子统计 start -->
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
 <!-- MathJax v3（推荐） -->
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <h1 id="os期中知识点汇总">OS期中知识点汇总</h1>
<h2 id="i.-引论与os结构"><strong>I. 引论与OS结构</strong></h2>
<ul>
<li><strong>OS 角色与功能:</strong>
<ul>
<li><strong>定义:</strong>
操作系统是<strong>管理计算机硬件资源的软件集合</strong>，向计算机程序提供<strong>共性</strong>服务。</li>
<li><strong>核心作用:</strong>
<ul>
<li><strong>资源管理者:</strong>
有效控制和管理计算机系统中的各种软硬件资源（处理机、存储器、I/O设备、文件等），提高资源利用率和系统效率（吞吐量、响应时间）。</li>
<li><strong>用户与硬件间的接口:</strong>
提供用户接口（如命令行Shell、图形界面GUI）和程序接口（API），屏蔽硬件复杂性，使计算机更易于使用。</li>
<li><strong>抽象/扩展机/虚拟机:</strong>
在裸机之上覆盖一层软件，实现对计算机资源的抽象，提供更强大、方便的功能。</li>
</ul></li>
<li><strong>主要功能模块:</strong>
<ul>
<li>处理机管理 (进程/线程控制、同步、通信、调度)</li>
<li>存储器管理 (内存分配、保护、地址映射、扩充)</li>
<li>设备管理 (I/O设备分配、操作、缓冲、虚拟设备)</li>
<li>文件管理 (文件存储空间管理、目录管理、读写、保护)</li>
<li>作业控制 (作业调度与控制)</li>
<li>用户接口 (提供给用户的操作界面)</li>
</ul></li>
<li><strong>设计目标:</strong> 方便性 (易用) 和 高效性
(资源利用率、吞吐量)。</li>
</ul></li>
<li><strong>启动过程 (Boot Process):</strong>
<ul>
<li><strong>Bootstrapping (引导):</strong>
计算机启动是一个“自举”过程，需要先运行程序才能启动，但不启动又无法运行程序。早期通过“拉鞋带”比喻，将一小段程序装入内存使计算机运行起来。</li>
<li><strong>BIOS/UEFI:</strong>
<ul>
<li><strong>BIOS (基本输入/输出系统):</strong>
固化在主板ROM/EEPROM中的固件。上电后CPU跳转到固定物理地址 0xFFFF0 (Intel
80386) 开始执行BIOS。</li>
<li><strong>BIOS 功能:</strong> 加载硬件信息 (CPU, 内存, 启动顺序等),
执行POST (Power-On Self-Test, 硬件自检),
根据启动顺序查找可引导设备。</li>
<li><strong>BIOS 局限:</strong>
16/20位实模式寻址能力有限，移植性差。</li>
<li><strong>UEFI (统一可扩展固件接口):</strong>
BIOS的现代替代品，克服了BIOS的限制。支持大容量硬盘(&gt;2TB,
GPT分区)、CPU无关架构和驱动、模块化设计、提供预操作系统环境（如网络功能）。</li>
</ul></li>
<li><strong>MBR (主引导记录):</strong>
<ul>
<li><strong>位置:</strong> 硬盘的第一个物理扇区 (0磁头0磁道1扇区)。</li>
<li><strong>大小:</strong> 512字节。</li>
<li><strong>结构:</strong>
<ul>
<li>引导代码 (Bootloader的一部分, 446字节)（预启动信息）。</li>
<li>硬盘分区表 (DPT, 4个16字节的分区项, 共64字节)。</li>
<li>结束标志/幻数 (Magic Number, 2字节, 0xAA55)。</li>
</ul></li>
<li><strong>作用:</strong> BIOS将MBR加载到内存 0x7C00
处并跳转执行。MBR代码检查分区表，找到活动分区，加载该分区的引导扇区(Boot
Sector)到 0x7C00 并执行。</li>
<li><strong><em>P.S.</em></strong>
MBR的主要功能是<strong>传递引导控制权</strong>，从BIOS传递到活动分区的引导扇区（或下一阶段的Boot
Loader），它本身<strong>不负责初始化磁盘</strong>（BIOS做了初步工作），也<strong>不直接加载操作系统内核</strong>。因此，原判断题的描述是不准确的。</li>
</ul></li>
<li><strong>引导扇区 (Boot Sector):</strong>
位于<strong>每个分区</strong>的第一个扇区，包含加载该分区操作系统的代码。MBR将<strong>活动分区</strong>的引导扇区加载并执行。</li>
<li><strong>Bootloader (引导加载程序):</strong>
<ul>
<li><strong>定义:</strong> 操作系统内核运行前执行的一段小程序。</li>
<li><strong>组成 (Booter + Loader):</strong> 初始化硬件
(Booter)，加载操作系统内核映像到内存并跳转执行 (Loader)。</li>
<li><strong>阶段:</strong> 常分为 Stage 1 (依赖硬件, 通常汇编实现,
如MBR或Boot Sector中的代码) 和 Stage 2 (功能更复杂, 通常C实现,
具有更好可读性和移植性)。</li>
<li><strong>常见类型:</strong> U-Boot (嵌入式常用), LILO, GRUB
(X86常用)。</li>
<li><strong>依赖性:</strong> 严重依赖具体硬件，常需移植。</li>
</ul></li>
<li><strong>加载内核:</strong>
<ul>
<li>Bootloader将内核映像 (可能是压缩的, 如zImage, bzImage)
从存储介质加载到内存指定位置。</li>
<li>进行必要的内存移动、解压缩。</li>
<li>初始化早期环境 (如堆栈)。</li>
<li>执行内核入口代码 (如Linux的 head.s 中的 kernel_entry 或
start_kernel)。</li>
<li>内核接管控制权，进行进一步初始化（内存管理、页表、调度器、设备驱动、中断等）。</li>
</ul></li>
<li><strong>启动 Init 进程:</strong>
内核初始化完成后，启动用户空间的第一个进程 /sbin/init。</li>
<li><strong>Init 进程工作:</strong> 读取 /etc/inittab
(或Systemd配置)，设置运行级别 (Runlevel)，执行相应的启动脚本
(rc.sysinit, rcX.d/*, rc.local)，最终启动登录程序 (getty/login)
等待用户登录。</li>
<li><strong>整体过程:</strong> 逐级引导，逐步释放系统灵活性。</li>
</ul></li>
<li><strong>内核态 (Kernel Mode) vs. 用户态 (User Mode):</strong>
<ul>
<li><strong>目的:</strong>
保护操作系统内核和关键系统资源不被用户程序破坏。</li>
<li><strong>内核态:</strong>
运行操作系统代码，具有最高权限，可访问所有硬件和内存，执行特权指令。</li>
<li><strong>用户态:</strong>
运行用户应用程序，权限受限，不能直接访问硬件，不能执行特权指令。</li>
<li><strong>特权指令:</strong>
只能在内核态执行的指令，如I/O操作、修改中断屏蔽字、修改内存管理寄存器、停机等。</li>
<li><strong>模式切换:</strong>
<ul>
<li>用户态 -&gt; 内核态: 通过中断、异常或系统调用（陷阱 Trap）。</li>
<li>内核态 -&gt; 用户态: 通过执行特定指令（如 iret 中断返回指令）。</li>
</ul></li>
<li><strong>保护边界:</strong>
通过硬件机制（如CPU模式位、MMU）强制隔离用户态和内核态。</li>
</ul></li>
<li><strong>系统调用 (System Calls):</strong>
<ul>
<li><strong>定义:</strong>
用户程序请求操作系统内核提供服务的接口。是用户态进入内核态的主要方式之一。</li>
<li><strong>机制:</strong> 通常通过特定的“陷阱”指令（如x86的 int 0x80 或
syscall）触发，将控制权转移给内核中的系统调用处理程序。</li>
<li><strong>实现:</strong>
<ul>
<li>用户程序将系统调用号和参数放入指定寄存器或内存。</li>
<li>执行陷阱指令，CPU切换到内核态。</li>
<li>内核根据系统调用号在系统调用分派表 (System service dispatch table)
中找到对应的服务例程地址。</li>
<li>执行内核服务例程。</li>
<li>执行完毕，将结果返回给用户程序，切换回用户态，从陷阱指令后继续执行。</li>
</ul></li>
<li><strong>例子:</strong> read(fd, buffer, nbytes)</li>
</ul></li>
<li><strong>中断 (Interrupts) 与 异常 (Exceptions):</strong>
<ul>
<li><strong>中断:</strong>
来自硬件设备（如I/O完成、定时器）的<strong>异步</strong>信号，与当前指令执行无关。可屏蔽或不可屏蔽。</li>
<li><strong>异常:</strong>
由CPU执行指令时内部产生的<strong>同步</strong>事件。
<ul>
<li><strong>陷阱 (Trap):</strong>
有意产生的异常，如系统调用、调试断点。通常在指令执行后处理，返回到下一条指令。</li>
<li><strong>故障 (Fault):</strong>
可恢复的错误，如缺页、除零错误。通常在指令执行前/中检测到，处理后返回到<strong>当前</strong>指令重新执行。</li>
<li><strong>终止 (Abort):</strong>
不可恢复的严重错误，如硬件错误。无法返回。</li>
</ul></li>
<li><strong>处理过程:</strong> CPU检测到中断/异常 -&gt; 保存当前状态
(PC, PSW等) -&gt; 根据中断/异常向量号查找中断处理程序入口地址 -&gt;
跳转执行中断处理程序 (ISR) -&gt; 恢复现场 -&gt; 返回原执行点。</li>
<li><strong>作用:</strong> 实现并发
(I/O与CPU并行)、处理错误、实现系统调用。</li>
</ul></li>
<li><strong>OS 类型与历史:</strong>
<ul>
<li><strong>史前:</strong> 无OS，手动操作。</li>
<li><strong>批处理系统:</strong>
<ul>
<li><strong>联机:</strong>
作业直接由CPU控制输入输出，CPU等待I/O，效率低。</li>
<li><strong>脱机:</strong>
使用卫星机处理I/O，主机与卫星机通过磁带交互，提高CPU利用率。</li>
<li><strong>多道批处理:</strong>
内存中驻留多个作业，CPU在一个作业等待I/O时切换到另一个作业，进一步提高效率。特点：多道、成批、无交互。</li>
</ul></li>
<li><strong>分时系统:</strong>
允许多用户通过终端同时与计算机交互。特点：多路性、交互性、独立性、及时性。关键技术：时间片轮转。</li>
<li><strong>实时系统:</strong>
对响应时间有严格要求。特点：及时响应、高可靠性、专用性。</li>
<li><strong>网络操作系统 (NOS):</strong>
提供网络通信和资源共享功能，但各计算机仍是独立的。</li>
<li><strong>分布式操作系统 (DOS):</strong>
将多台计算机联结成一个逻辑整体，对用户透明。</li>
<li><strong>嵌入式操作系统:</strong> 面向特定应用，资源受限。</li>
<li><strong>混合型:</strong> 现代操作系统通常结合多种类型特点。</li>
</ul></li>
<li>**存储层次结构 (Memory Hierarchy):
<ul>
<li><strong>结构:</strong> 寄存器 -&gt; Cache (L1, L2, L3) -&gt; 主存
(RAM) -&gt; 辅存 (磁盘/SSD) -&gt; 备份存储 (磁带)。</li>
<li><strong>特点:</strong> 越靠近CPU速度越快、容量越小、成本越高。</li>
<li><strong>速度差异:</strong> CPU与内存/I/O存在巨大速度差异
("内存墙"问题)，Cache用于缓解此问题。</li>
<li><strong>管理:</strong>
操作系统主要负责主存及辅存的管理，对Cache的管理通常由硬件完成，但OS需要考虑Cache一致性等问题。</li>
</ul></li>
<li><strong>操作系统结构 (OS Structure):</strong>
<ul>
<li><strong>模块化:</strong>
将OS划分为功能模块，通过接口交互。优点：灵活性、易修改维护；缺点：接口定义困难。</li>
<li><strong>分层结构:</strong>
将OS功能组织成有序层次，下层为上层提供服务。优点：结构清晰、易验证；缺点：效率可能较低，层间依赖严格。</li>
<li><strong>微内核:</strong>
内核只保留最基本功能（IPC、基本调度、中断处理），其他服务（文件系统、内存管理、设备驱动）作为用户态服务器进程运行。优点：可靠性、灵活性、可移植性；缺点：性能开销（进程间通信频繁）。</li>
<li><strong>虚拟机 (VM):</strong>
在硬件之上创建一层软件（虚拟机监视器VMM/Hypervisor），模拟出多个裸机环境，每个环境可运行独立操作系统。支持遗留系统、隔离性好。</li>
<li><strong>混合结构:</strong> 如类微内核（Windows NT）或宏内核（Linux,
Unix）结合了不同结构的特点。</li>
<li><strong>机制与策略分离:</strong>
将“如何做”（机制）与“做什么”（策略）分开，增加系统灵活性和可扩展性。</li>
</ul></li>
</ul>
<h2 id="ii.-进程管理"><strong>II. 进程管理</strong></h2>
<ol type="1">
<li><strong>进程概念 (Process Concept):</strong>
<ul>
<li><strong>引入原因:</strong>
<ul>
<li>程序的并发执行带来了间断性、非封闭性和不可再现性等问题
，单纯的“程序”概念无法描述和管理这种动态、并发的活动。</li>
<li>“程序”是静态的指令集合，而“计算/执行”是动态的过程，两者并非一一对应。</li>
<li>多道程序环境下，资源（如CPU、内存）受限，程序执行会走走停停，需要一种机制来管理这种状态。</li>
<li>最早在 MULTICS 和 IBM CTSS/360 等系统中引入。</li>
</ul></li>
<li><strong>定义:</strong>
<ul>
<li>进程是程序的一次执行过程。</li>
<li>进程是一个程序及其数据在处理机上<strong>顺序执行</strong>时所发生的活动。</li>
<li>进程是可以和别的计算并发执行的计算。</li>
<li>进程是程序在一个数据集合上运行的过程。</li>
<li><strong>核心角色:</strong>
进程是操作系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个<strong>独立单位</strong>。</li>
</ul></li>
<li><strong>与程序的区别:</strong>
<ul>
<li><strong>动态 vs. 静态:</strong>
进程是动态的执行过程，程序是静态的代码集合。</li>
<li><strong>生命周期:</strong>
进程是暂时的（有创建、运行、消亡），程序是永久的（可存储）。</li>
<li><strong>组成:</strong> 进程包含程序、数据和<strong>进程控制块
(PCB)</strong>，程序只是代码。</li>
<li><strong>对应关系:</strong>
一个程序可以对应多个进程（多次执行），一个进程在其执行过程中可能调用多个程序。</li>
</ul></li>
<li><strong>特征:</strong>
<ul>
<li><strong>动态性:</strong> 进程有生命周期，状态会变化。</li>
<li><strong>并发性:</strong>
多个进程实体可同时存在于内存中并交替执行。</li>
<li><strong>独立性:</strong>
作为资源分配和调度的基本单位，独立运行。</li>
<li><strong>异步性:</strong>
进程按各自独立的、不可预知的速度推进，相互制约。</li>
</ul></li>
</ul></li>
<li><strong>进程控制块 (PCB - Process Control Block):</strong>
<ul>
<li><strong>定义:</strong>
操作系统为管理和控制进程而定义的<strong>数据结构</strong>，是进程存在的<strong>唯一标志</strong>。</li>
<li><strong>作用:</strong>
保存进程的状态信息，使得进程可以被中断和恢复，实现并发。OS通过PCB来管理和调度进程。</li>
<li><strong>生命周期:</strong>
PCB在进程创建时建立，伴随进程整个生命周期，进程撤销时回收。</li>
<li><strong>包含信息 (主要内容):</strong>
<ul>
<li><strong>进程标识符 (PID):</strong> 唯一的内部ID。</li>
<li><strong>进程状态:</strong> 如就绪、运行、阻塞等。</li>
<li><strong>程序计数器 (PC):</strong> 指向下一条要执行的指令地址。</li>
<li><strong>CPU寄存器:</strong>
通用寄存器、状态寄存器等的副本（用于上下文切换时恢复）。</li>
<li><strong>CPU调度信息:</strong> 进程优先级、调度队列指针等。</li>
<li><strong>内存管理信息:</strong> 页表或段表的指针、内存界限等。</li>
<li><strong>记账信息:</strong> CPU使用时间、时间限制等。</li>
<li><strong>I/O状态信息:</strong>
分配给进程的I/O设备、打开文件列表等。</li>
<li><strong>进程间通信/同步信息:</strong> 信号量、消息队列指针等。</li>
<li><strong>家族关系:</strong> 父进程ID (PPID)、子进程列表指针等。</li>
<li><strong>链接指针:</strong>
用于将PCB组织到不同的状态队列（如就绪队列、阻塞队列）。</li>
</ul></li>
<li><strong>组织方式:</strong>
<ul>
<li><strong>线性表:</strong>
将所有PCB存在一个数组中，简单但查找效率低，不易于状态管理。</li>
<li><strong>索引表:</strong> 按状态建立不同的索引表，指向PCB。</li>
<li><strong>链接表:</strong>
按状态将PCB组织成链式队列（如就绪队列、各事件的阻塞队列），最常用、灵活。</li>
</ul></li>
<li><strong>Linux 实现:</strong> Linux 内核中使用 task_struct
结构体作为PCB。</li>
</ul></li>
<li><strong>进程状态 (Process States):</strong>
<ul>
<li><strong>基本状态 (三种):</strong>
<ul>
<li><strong>运行 (Running):</strong> 进程正在CPU上执行。</li>
<li><strong>就绪 (Ready):</strong>
进程已获得除CPU外的所有资源，等待被调度执行。</li>
<li><strong>阻塞/等待 (Blocked/Waiting):</strong>
进程因等待某个事件（如I/O完成、资源可用、信号）而暂停执行。</li>
</ul></li>
<li><strong>扩展状态 (五种):</strong>
<ul>
<li><strong>新建 (New):</strong> 进程正在被创建，尚未准备好运行。</li>
<li><strong>就绪 (Ready):</strong> 同上。</li>
<li><strong>运行 (Running):</strong> 同上。</li>
<li><strong>阻塞/等待 (Waiting):</strong> 同上。</li>
<li><strong>终止 (Terminated):</strong>
进程执行完毕或被终止，正在进行资源回收。</li>
</ul></li>
<li><strong>状态转换:</strong>
<ul>
<li><strong>新建 -&gt; 就绪 (Admitted):</strong>
进程创建完成，资源基本分配到位。</li>
<li><strong>就绪 -&gt; 运行 (Scheduler Dispatch):</strong>
调度程序选中该进程，分配CPU。</li>
<li><strong>运行 -&gt; 就绪 (Interrupt/Timeout):</strong>
时间片用完或被更高优先级进程抢占。</li>
<li><strong>运行 -&gt; 阻塞 (I/O or Event Wait):</strong>
进程请求I/O或等待某个事件发生。<strong>（这是进程自身可以决定的转换）</strong></li>
<li><strong>阻塞 -&gt; 就绪 (I/O or Event Completion):</strong>
等待的事件发生（如I/O完成）。</li>
<li><strong>运行 -&gt; 终止 (Exit):</strong>
进程正常完成或出错终止。</li>
</ul></li>
</ul></li>
<li><strong>进程创建与终止:</strong>
<ul>
<li><strong>创建 (Creation):</strong>
<ul>
<li><strong>时机/情形:</strong>
用户登录、批处理作业提交、提供服务（如Web服务器创建子进程处理请求）、一个进程创建另一个进程。</li>
<li><strong>原语:</strong> 操作系统提供创建进程的原语（如 fork,
exec）。</li>
<li><strong>fork() 系统调用:</strong> (Unix/Linux)
创建一个与父进程几乎完全一样的子进程。关键在于：
<ul>
<li>调用一次，返回两次。</li>
<li>父进程中返回子进程的PID。</li>
<li>子进程中返回 0。</li>
<li>子进程复制父进程的地址空间（通常使用写时复制 CoW
优化）、文件描述符等。</li>
</ul></li>
<li><strong>创建过程:</strong> 分配PID -&gt; 创建PCB -&gt;
分配资源（如内存空间） -&gt; 初始化PCB -&gt; 插入就绪队列。</li>
</ul></li>
<li><strong>终止 (Termination):</strong>
<ul>
<li><strong>时机/情形:</strong>
正常完成、出错（如非法指令、内存访问越界）、被其他进程终止（如父进程终止子进程
kill）、用户退出登录、达到时限等。</li>
<li><strong>原语:</strong> 操作系统提供终止进程的原语（如 exit,
kill）。</li>
<li><strong>终止过程:</strong> 设置进程状态为终止 -&gt; 回收占用的资源
-&gt; 回收PCB。</li>
</ul></li>
<li><strong>进程树:</strong> 进程间存在父子关系，形成树状结构。</li>
</ul></li>
<li><strong>上下文切换 (Context Switching):</strong>
<ul>
<li><strong>定义:</strong>
CPU从一个进程（或线程）转换到另一个进程（或线程）去执行的过程。</li>
<li><strong>时机:</strong> 中断处理、调度程序运行时。</li>
<li><strong>过程:</strong>
<ul>
<li>保存当前运行进程的上下文（CPU寄存器状态、PC、PSW等到其PCB中）。</li>
<li>更新当前进程的PCB信息（如状态变为就绪或阻塞）。</li>
<li>将该PCB移到相应的队列（就绪或阻塞）。</li>
<li>选择一个新的就绪进程。</li>
<li>更新新进程的PCB（状态变为运行）。</li>
<li>根据新进程PCB恢复其上下文（加载寄存器、PC、PSW等）。</li>
<li><strong>切换内存映射</strong>（更新页表基址寄存器，可能需要刷新TLB）。</li>
</ul></li>
<li><strong>与模式切换 (Mode Switch) 的区别:</strong>
<ul>
<li><strong>模式切换:</strong>
CPU运行状态从用户态到内核态（或反之）的切换，通常由中断、异常、系统调用引起。只涉及少量CPU状态（如PC、PSW、部分寄存器）的保存和恢复。<strong>开销相对较小。</strong></li>
<li><strong>上下文切换:</strong>
必须在<strong>内核态</strong>完成，包含模式切换，但还涉及调度、PCB操作、内存管理（页表切换、TLB刷新）等更复杂、<strong>开销更大</strong>的操作。</li>
</ul></li>
<li><strong>开销:</strong>
上下文切换是纯粹的系统开销，需要尽量减少其频率和耗时。</li>
</ul></li>
<li><strong>进程间通信 (IPC - Inter-Process Communication):</strong>
<ul>
<li><strong>必要性:</strong>
进程是独立地址空间的，需要机制来<strong>交换信息</strong>和协作。</li>
<li><strong>方式:</strong>
<ul>
<li><strong>低级通信:</strong>
传递状态和整数值（如信号量，用于同步互斥）。</li>
<li><strong>高级通信:</strong> 传递任意数量数据。主要包括：
<ul>
<li>管道 (Pipe) / 命名管道 (FIFO)</li>
<li>消息队列 (Message Queue)</li>
<li><strong>共享内存 (Shared Memory):</strong>
将同一块物理内存映射到不同进程的地址空间，允许进程直接读写，<strong>效率最高</strong>，但需要额外的同步机制。</li>
<li>信号量 (Semaphore) - 也可用于传递简单信息</li>
<li>套接字 (Socket) - 主要用于网络通信</li>
<li>信号 (Signal) - 异步通知事件</li>
</ul></li>
</ul></li>
<li><em>(本课件主要在同步章节详细讲解IPC，此处仅提及共享内存作为高效方式)</em></li>
</ul></li>
<li><strong>程序内存布局:</strong>
<ul>
<li>进程拥有独立的虚拟地址空间。</li>
<li>典型布局（Linux/MIPS示例）：
<ul>
<li>用户空间 (kuseg): 应用程序代码 (.text)、已初始化数据
(.data)、未初始化数据 (.bss)、堆 (heap, malloc分配)、栈 (stack,
函数调用)。</li>
<li>内核空间 (kseg0, kseg1, kseg2):
操作系统内核代码和数据、共享库映射区、内核栈等。用户态不可直接访问。</li>
</ul></li>
<li>PCB中存储了指向这些区域的相关信息（如页表指针）。</li>
</ul></li>
<li><strong>程序加载与链接:</strong>
<ul>
<li><strong>加载:</strong>
操作系统负责将可执行文件从磁盘读入内存，创建进程映像，设置PC指向入口点。</li>
<li><strong>链接:</strong>
将编译后的目标文件和库文件组合成可执行文件的过程（静态链接）或在运行时加载共享库（动态链接）。</li>
</ul></li>
</ol>
<h2 id="iii.-线程-thread"><strong>III. 线程 (Thread)</strong></h2>
<ol type="1">
<li><strong>线程概念:</strong>
<ul>
<li><strong>引入动机/进程的不足:</strong>
<ul>
<li>进程作为资源分配和调度的单位，创建和切换开销较大。</li>
<li>进程在一个时间只能做一件事；若想并发执行多个任务（如Web服务器同时处理多个请求，或字处理软件同时输入、检查、显示），用多进程方式实现，进程间通信和共享数据复杂且效率低。</li>
<li>若进程中某个执行流因I/O等原因阻塞，整个进程都会挂起，即使进程中其他部分不依赖该阻塞操作也无法执行。</li>
</ul></li>
<li><strong>定义:</strong>
<ul>
<li>线程是<strong>进程内</strong>的一个<strong>执行单元/实体</strong>。</li>
<li>是操作系统能够进行<strong>CPU调度</strong>和<strong>分派</strong>的基本单位。</li>
<li>也称为<strong>轻量级进程 (Lightweight Process,
LWP)</strong>，尤其是在混合模型中。</li>
</ul></li>
<li><strong>核心思想:</strong>
将传统进程的两个属性——“资源拥有者”和“可执行单元”——进行<strong>分离</strong>。进程继续作为资源（地址空间、文件等）的拥有者，而线程作为执行的实体。</li>
</ul></li>
<li><strong>进程 vs. 线程:</strong>
<ul>
<li><strong>资源所有权:</strong>
<ul>
<li><strong>进程:</strong>
拥有独立的地址空间、文件句柄、I/O设备等系统资源，是<strong>资源分配</strong>的基本单位。</li>
<li><strong>线程:</strong>
<strong>基本上不拥有系统资源</strong>（除了必需的如PC、寄存器、栈），它<strong>共享</strong>其所属进程的<strong>所有资源</strong>（包括地址空间、全局变量、打开的文件、信号处理等）。</li>
</ul></li>
<li><strong>调度单位:</strong>
<ul>
<li><strong>进程:</strong> 传统上也是调度单位。</li>
<li><strong>线程:</strong>
是<strong>CPU调度</strong>的基本单位。OS调度器选择线程来运行。</li>
</ul></li>
<li><strong>独立性/通信:</strong>
<ul>
<li><strong>进程:</strong>
具有较强的独立性，地址空间隔离，进程间通信（IPC）需要内核特殊机制（管道、消息队列、共享内存等），相对复杂且开销大。</li>
<li><strong>线程:</strong>
同一进程内的线程<strong>共享地址空间</strong>，通信非常方便（直接读写全局变量、堆内存，传递指针），但也因此需要<strong>显式同步</strong>来避免数据竞争。</li>
</ul></li>
<li><strong>开销:</strong>
<ul>
<li><strong>创建/撤销:</strong>
创建线程比创建进程<strong>快得多</strong>（通常10-100倍），因为不需要分配和初始化那么多资源（如地址空间、页表）。</li>
<li><strong>切换:</strong>
线程上下文切换比进程上下文切换<strong>开销小</strong>，因为通常只需要保存/恢复线程私有的寄存器和栈指针，而不需要切换地址空间（页表）。</li>
</ul></li>
<li><strong>并发性:</strong> 线程提供了更细粒度的并发。</li>
<li><strong>私有成分 vs. 共享成分:</strong>
<ul>
<li><strong>线程私有:</strong> 线程ID (TID)、程序计数器
(PC)、寄存器集合、<strong>栈 (Stack)</strong>、线程局部存储 (TLS)。</li>
<li><strong>进程共享 (线程间共享):</strong>
代码段、数据段、堆内存、文件描述符、信号处理方式、当前工作目录、用户和组ID等。</li>
</ul></li>
</ul></li>
<li><strong>多线程 (Multithreading):</strong>
<ul>
<li><strong>定义:</strong> 一个进程包含多个线程。</li>
<li><strong>优点:</strong>
<ul>
<li><strong>提高响应速度:</strong>
如GUI程序，可以将耗时操作（如I/O、复杂计算）放在后台线程，保持UI线程响应用户操作。</li>
<li><strong>资源共享方便:</strong> 线程间通过共享内存高效通信。</li>
<li><strong>经济性:</strong> 创建和切换线程开销远小于进程。</li>
<li><strong>提高系统吞吐量/并发度:</strong>
在多核CPU上，不同线程可以真正并行执行，充分利用硬件资源。</li>
</ul></li>
<li><strong>潜在开销与挑战:</strong>
<ul>
<li><strong>同步开销:</strong>
需要使用锁、信号量等机制保护共享数据，带来额外开销和复杂性。</li>
<li><strong>上下文切换开销:</strong>
虽然比进程切换小，但频繁切换仍有开销。</li>
<li><strong>编程复杂性:</strong>
多线程程序设计和调试比单线程程序更困难，容易出现死锁、竞争条件等问题。</li>
</ul></li>
</ul></li>
<li><strong>用户级线程 (User-Level Threads, ULT) vs. 内核级线程
(Kernel-Level Threads, KLT):</strong>
<ul>
<li><strong>实现方式:</strong>
<ul>
<li><strong>ULT:</strong>
完全在<strong>用户空间</strong>实现，由应用程序通过<strong>线程库
(library)</strong> 进行管理
(创建、调度、同步)。内核<strong>不知道</strong>线程的存在，只认进程。</li>
<li><strong>KLT:</strong>
由<strong>操作系统内核</strong>直接支持和管理。线程的创建、调度、管理都是内核负责。</li>
</ul></li>
<li><strong>内核感知:</strong>
<ul>
<li><strong>ULT:</strong> 内核不可感知。</li>
<li><strong>KLT:</strong> 内核可感知。</li>
</ul></li>
<li><strong>创建与管理:</strong>
<ul>
<li><strong>ULT:</strong>
通过调用线程库函数完成，速度快，无需系统调用。</li>
<li><strong>KLT:</strong>
需要执行系统调用，由内核完成，速度相对较慢。</li>
</ul></li>
<li><strong>调度与切换:</strong>
<ul>
<li><strong>ULT:</strong>
调度由用户级线程库实现（可定制），切换<strong>非常快</strong>，仅需保存/恢复少量寄存器，<strong>无需模式切换</strong>。</li>
<li><strong>KLT:</strong>
调度由内核调度器完成，切换需要<strong>完整的上下文切换</strong>（可能包括模式切换），速度相对较慢。</li>
</ul></li>
<li><strong>阻塞行为:</strong> (关键区别)
<ul>
<li><strong>ULT:</strong>
如果一个ULT执行了<strong>阻塞型系统调用</strong>（如读文件），那么<strong>整个进程</strong>（包含其所有ULT）都会被内核阻塞，因为内核只知道这个进程在等待。</li>
<li><strong>KLT:</strong>
如果一个KLT阻塞，内核可以调度<strong>同一进程</strong>的<strong>其他</strong>KLT或<strong>其他进程</strong>的KLT来运行。</li>
</ul></li>
<li><strong>系统调用处理:</strong>
<ul>
<li><strong>ULT:</strong>
系统调用由进程（内核线程）发出，可能导致整个进程阻塞。</li>
<li><strong>KLT:</strong> 系统调用由线程发出，阻塞只会影响该线程。</li>
</ul></li>
<li><strong>并行性:</strong>
<ul>
<li><strong>ULT (Many-to-One模型):</strong>
无法利用多核处理器实现真正的并行，因为内核一次只能调度一个进程（对应一个内核线程）到CPU上。</li>
<li><strong>KLT:</strong>
可以被内核调度到不同的CPU核心上，实现真正的并行。</li>
</ul></li>
<li><strong>修改页表的能力:</strong>
无论是ULT还是KLT，修改页表都是<strong>内核</strong>的特权操作。用户级代码（包括线程库）不能直接修改页表。KLT的切换可能伴随内核进行的页表相关操作，但并非线程自身能力。</li>
<li><strong>线程模型:</strong>
<ul>
<li><strong>多对一 (Many-to-One):</strong>
多个ULT映射到一个KLT。实现简单，但有阻塞问题和并行限制。</li>
<li><strong>一对一 (One-to-One):</strong>
每个ULT对应一个KLT。并发性好，阻塞问题解决，但创建KLT开销大。</li>
<li><strong>多对多 (Many-to-Many):</strong>
多个ULT映射到<strong>小于等于</strong>ULT数量的KLT（或LWP）。兼具两者优点，较复杂。</li>
</ul></li>
</ul></li>
<li><strong>线程通信:</strong>
<ul>
<li>主要方式是<strong>共享内存</strong>，因为它们共享进程的地址空间（全局变量、堆）。</li>
<li>可以直接读写共享变量或通过指针访问共享数据结构。</li>
<li>线程库也可能提供消息传递等机制。</li>
<li><strong>必须进行同步</strong>以保护共享数据。</li>
</ul></li>
<li><strong>线程特定数据:</strong>
<ul>
<li>虽然线程共享大部分进程资源，但每个线程必须拥有自己独立的：
<ul>
<li><strong>程序计数器 (PC):</strong> 指示下一条要执行的指令。</li>
<li><strong>寄存器集合:</strong> 保存线程当前的运算状态。</li>
<li><strong>栈 (Stack):</strong>
用于存储局部变量、函数参数、返回地址等。<strong>这是线程独立性的重要体现。</strong></li>
</ul></li>
<li><strong>线程局部存储 (Thread-Local Storage, TLS):</strong>
一种机制，允许线程拥有看似全局或静态，但实际上是线程私有的数据副本（例如，解决多线程环境下errno全局变量的覆盖问题）。</li>
</ul></li>
</ol>
<h2 id="iv.-cpu-调度"><strong>IV. CPU 调度</strong></h2>
<ul>
<li><strong>基本概念:</strong> （之前已有）目标、抢占等。</li>
<li><strong>调度队列:</strong> （之前已有）就绪队列、阻塞队列等。</li>
<li><strong>优先级调度问题:</strong>
<ul>
<li><strong>优先级反转 (Priority Inversion):</strong>
<ul>
<li><strong>问题定义:</strong>
一个高优先级进程（或线程）被一个低优先级进程（或线程）阻塞，而该低优先级进程又无法执行（因为它被一个中优先级进程抢占），导致高优先级进程长时间等待。</li>
<li><strong>发生场景:</strong>
当低优先级进程持有高优先级进程所需的锁（如进入了临界区）时。</li>
<li><strong>解决方案 :</strong> 优先级继承 (Priority
Inheritance)、优先级天花板 (Priority Ceiling Protocol)。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="v.-进程同步"><strong>V. 进程同步</strong></h2>
<ol type="1">
<li><strong>并发与同步/互斥基础:</strong>
<ul>
<li><strong>并发执行特征:</strong> 间断性、非封闭性、不可再现性。</li>
<li><strong>产生的问题:</strong> 资源争夺、与时间有关的错误。</li>
<li><strong>竞争条件 (Race Condition):</strong>
多个进程/线程并发访问和操作同一共享数据，执行结果取决于访问发生的特定顺序。</li>
<li><strong>临界资源 (Critical Resource):</strong>
一次仅允许一个进程/线程访问的共享资源（如打印机、共享变量）。</li>
<li><strong>临界区 (Critical Section):</strong>
进程/线程中访问临界资源的那段代码。</li>
<li><strong>进程互斥 (Mutual Exclusion):</strong>
确保任意时刻最多只有一个进程/线程在临界区内执行，是对临界资源的排他性访问。</li>
<li><strong>进程同步 (Synchronization):</strong>
协调并发进程/线程间的执行顺序，使它们能有效共享资源和协作完成任务（直接制约关系）。</li>
<li><strong>互斥与同步的区别与联系:</strong>
互斥是排他性访问，同步是协调执行次序。同步通常包含互斥。</li>
<li><strong>临界区管理需满足的条件/准则:</strong>
<ul>
<li><strong>互斥进入 (Mutual Exclusion):</strong> 一次最多一个。</li>
<li><strong>有空让进 (Progress):</strong>
无进程在临界区且有进程想进入时，不能无限延迟选择。</li>
<li><strong>有限等待 (Bounded Waiting):</strong>
进程请求进入临界区的等待时间必须有限。</li>
<li><strong>(让权等待):</strong>
无法进入临界区时应释放CPU，避免忙等。</li>
</ul></li>
<li><strong>Bernstein 条件:</strong>
判断两个语句/进程段是否可以并发执行而结果可再现的充分条件（基于读写集分析）。</li>
</ul></li>
<li><strong>实现同步/互斥的方法:</strong>
<ul>
<li><strong>基于忙等待 (Busy-Waiting) 的方法:</strong>
<ul>
<li><strong>软件方法:</strong>
<ul>
<li>尝试1 (轮转法 turn): 违反 Progress。</li>
<li>尝试2 (标志法 Occupied): 不能保证互斥。</li>
<li>尝试3 (双标志法 pturn, qturn): 可能都无法进入，违反 Progress。</li>
<li>尝试4 (双标志+让权): 破坏互斥。</li>
<li><strong>Dekker 算法 (1965):</strong>
第一个正确的纯软件解法，结合标志和轮转。</li>
<li><strong>Peterson 算法 (1981):</strong>
更简洁的软件解法，适用于两个进程。</li>
<li><strong>Lamport 面包店算法 (Bakery Algorithm):</strong>
适用于N个进程的软件解法，基于取号排队思想。</li>
<li><strong>软件方法缺点:</strong>
普遍存在<strong>忙等待</strong>问题，浪费CPU。</li>
</ul></li>
<li><strong>硬件方法:</strong>
<ul>
<li><strong>中断屏蔽:</strong>
<ul>
<li>方法：进临界区前关中断，出临界区后开中断。</li>
<li>优点：简单。</li>
<li>缺点：代价高（影响系统效率和时钟），不适用于多CPU，用户进程使用危险。主要用于内核自身短临界区。</li>
</ul></li>
<li><strong>原子指令 (Test-and-Set, TSL):</strong>
<ul>
<li>TestAndSet(lock): 原子地读取 lock 的旧值并将其设为 true。</li>
<li><strong>自旋锁 (Spinlock):</strong>
基于TSL实现，循环测试锁直到获取。</li>
</ul></li>
<li><strong>原子指令 (Swap/XCHG):</strong>
原子地交换内存单元和寄存器（或两个内存单元）的值。也可用于实现锁。</li>
<li><strong>原子指令 (MIPS LL/SC - Load Linked / Store
Conditional):</strong>
更精巧的原子操作对，用于实现无锁数据结构或高效锁。LL 读取并标记，SC
仅在标记未被清除（即期间无其他写操作）时才写入并返回成功。</li>
<li><strong>硬件方法缺点:</strong>
仍然是<strong>忙等待</strong>，浪费CPU，可能导致<strong>优先级反转</strong>。</li>
</ul></li>
</ul></li>
<li><strong>基于阻塞等待的同步原语:</strong>
<ul>
<li><strong>基本思路 (Sleep/Wakeup):</strong> 进程等待条件不满足时调用
Sleep 阻塞自己，条件满足时由其他进程调用 Wakeup(pid)
唤醒。存在“丢失的唤醒”问题（未详述）。</li>
<li><strong>信号量 (Semaphore):</strong> (Dijkstra, 1965)
<ul>
<li><strong>定义:</strong> 一个包含<strong>整数值 (count)</strong>
和一个<strong>等待队列 (queue)</strong> 的数据结构。</li>
<li><strong>类型:</strong>
<ul>
<li>二元信号量 (Binary Semaphore / Mutex):
值只能为0或1，常用于互斥。</li>
<li>计数信号量 (Counting Semaphore):
值可为任意非负整数，常用于资源计数。</li>
<li>强信号量 vs. 弱信号量: 队列管理方式（FIFO vs. 无序）。</li>
</ul></li>
<li><strong>原子操作 (P / wait / down 和 V / signal / up):</strong>
<ul>
<li>P(S) 或 wait(S): S.count--；如果 S.count &lt;
0，则阻塞调用进程并加入 S.queue。</li>
<li>V(S) 或 signal(S): S.count++；如果 S.count &lt;= 0，则从 S.queue
唤醒一个进程。</li>
</ul></li>
<li><strong>物理意义:</strong> S.count &gt;= 0 表示可用资源数；S.count
&lt; 0 其绝对值表示等待该资源的进程数。</li>
<li><strong>实现:</strong>
P/V操作必须原子执行，可通过关中断或硬件原子指令（如TSL、CAS）保护。</li>
<li><strong>应用:</strong> 实现互斥 、有限并发、进程同步</li>
<li><strong>信号量集 (Semaphore Set):</strong> 一次性申请/释放多个资源。
<ul>
<li>AND 型: 所有资源都满足才分配。</li>
<li>一般型: 对每个资源可指定不同需求量(ti)和占用量(di)。</li>
</ul></li>
<li><strong>优缺点:</strong>
表达能力强，但使用易出错（PV顺序、忘记V等），可能导致死锁。</li>
</ul></li>
<li><strong>管程 (Monitor):</strong> (Hoare/Hanson, 1973)
<ul>
<li><strong>动机:</strong>
解决信号量编程复杂、易错的问题，提供更高级的同步抽象。</li>
<li><strong>定义:</strong>
一种语言结构（模块），包含共享数据、对数据操作的一组过程、以及初始化代码。</li>
<li><strong>特性:</strong>
<ul>
<li><strong>互斥:</strong>
任何时刻只有一个进程能在管程内执行其过程（由编译器保证）。</li>
<li><strong>条件变量 (Condition Variable, CV):</strong>
用于进程在管程内等待特定条件满足。CV本身不存值，只有等待队列。</li>
<li><strong>CV操作:</strong> wait(cv)
(阻塞当前进程并释放管程锁，加入cv队列)，signal(cv)
(唤醒cv队列中的一个等待进程)。</li>
</ul></li>
<li><strong>CV 与信号量的区别:</strong> wait 总阻塞，signal
若无等待者则无效；信号量P不一定阻塞，V总改变计数值。</li>
<li><strong>signal 语义:</strong>
<ul>
<li>Hoare 管程:
signal后，唤醒者(P)等待，被唤醒者(Q)立即执行。引入紧急等待队列。</li>
<li>Mesa 管程: signal后，被唤醒者(Q)变就绪，唤醒者(P)继续执行。</li>
</ul></li>
<li><strong>实现 (Hoare管程使用信号量):</strong> 需要 mutex
(管程入口互斥), next (紧急等待队列信号量), next_count, 以及每个CV对应的
x-sem 和 x-count。</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>进程间通信 (IPC - Inter-Process Communication):</strong>
<ul>
<li><strong>分类:</strong>
<ul>
<li>低级通信: 传递状态/控制信息（如信号量、管程本身）。</li>
<li>高级通信: 传递任意数据。</li>
</ul></li>
<li><strong>常见高级IPC机制:</strong>
<ul>
<li><strong>管道 (Pipe):</strong>
<ul>
<li>无名管道: 半双工，只能用于父子/兄弟进程，存在于内存中。</li>
<li>有名管道 (FIFO): 有文件系统路径，允许无亲缘关系进程通信。</li>
</ul></li>
<li><strong>消息传递 (Message Passing):</strong>
<ul>
<li>原语: send(destination, message), receive(source, message)。</li>
<li>方式: 阻塞/非阻塞。</li>
<li>寻址: 直接通信/间接通信 (邮箱 Mailbox)。</li>
</ul></li>
<li><strong>共享内存 (Shared Memory):</strong>
<ul>
<li>机制: 将同一物理内存映射到不同进程的虚拟地址空间。</li>
<li><strong>优点:</strong> 速度最快（无内核干预的数据传输）。</li>
<li><strong>缺点:</strong>
需要外部同步机制（如信号量、互斥锁）来保证访问正确性。</li>
</ul></li>
<li>信号量 (Semaphore): 也可用于简单通信。</li>
<li>套接字 (Socket): 主要用于网络通信，也可用于本机IPC。</li>
<li>信号 (Signal): 异步通知机制。</li>
</ul></li>
<li><strong>POSIX IPC 接口:</strong>
提供了对信号量、消息队列、共享内存的标准API。</li>
</ul></li>
<li><strong>经典同步问题:</strong>
<ul>
<li><strong>生产者-消费者问题 (Bounded Buffer Problem):</strong>
<ul>
<li>描述: 生产者放数据到缓冲区，消费者取数据，缓冲区大小有限。</li>
<li>关系:
生产者/消费者之间互斥访问缓冲区，生产者需等待缓冲区有空位，消费者需等待缓冲区有数据（同步）。</li>
<li>信号量解法: mutex (互斥访问缓冲区), empty (空槽位计数), full
(满槽位计数)。注意PV操作顺序避免死锁。</li>
<li>管程解法: 使用管程封装缓冲区和计数器，用条件变量 full, empty。</li>
<li>扩展: 银行柜台问题。</li>
</ul></li>
<li><strong>读者-写者问题 (Readers-Writers Problem):</strong>
<ul>
<li>描述:
允许多个读者同时读，但写者必须独占访问。读写互斥，写写互斥。</li>
<li>信号量解法 (读者优先): rmutex (互斥访问 readcount), fmutex
(互斥访问文件/数据), readcount (记录当前读者数)。</li>
<li>问题: 可能导致写者饥饿。</li>
<li>公平解法 (使用闸机 Turnstile / Lightswitch 概念): 引入额外机制（如
turnstile 信号量）控制入口，防止新读者在写者等待时进入。</li>
</ul></li>
<li><strong>哲学家进餐问题 (Dining Philosophers Problem):</strong>
<ul>
<li>描述: 5个哲学家围桌吃饭，每人需要左右两根筷子才能吃。</li>
<li>问题: 可能发生死锁（所有人都拿起左手筷子）。</li>
<li>解法思路:
限制同时进餐人数；奇偶编号不同拿筷顺序；原子地拿两根筷子。</li>
</ul></li>
<li><strong>睡眠理发师问题 (Sleeping Barber Problem):</strong>
<ul>
<li>描述: 理发师等待顾客，顾客等待理发师或空椅子。</li>
<li>关系:
顾客唤醒理发师，理发师服务完一个顾客后可能唤醒下一个等待的顾客。互斥访问等待椅子计数。</li>
<li>信号量解法: customers (等待理发的顾客数), barbers (空闲理发师数),
mutex (互斥访问 waiting 计数器)。</li>
</ul></li>
<li><strong>H2O 构建问题:</strong>
<ul>
<li>描述: H、O原子线程需要同步形成H2O分子。</li>
<li>解法: 使用信号量/计数器跟踪H、O原子数量，使用 Barrier
(或其他同步机制如信号量实现的条件等待) 确保2H和1O都到达后才能
bond，并释放一个 mutex。</li>
</ul></li>
</ul></li>
</ol>
<p><strong>VI. 内存管理</strong></p>
<ol type="1">
<li><strong>基本概念:</strong>
<ul>
<li><strong>内存的角色:</strong>
内存是CPU能<strong>直接访问</strong>的唯一存储介质（不含寄存器和Cache），程序和数据必须装入内存才能运行。</li>
<li><strong>内存管理的目标:</strong>
<ul>
<li><strong>抽象:</strong>
向程序员提供方便易用的逻辑地址空间，屏蔽物理内存的复杂性。</li>
<li><strong>保护:</strong>
确保每个进程在自己的地址空间内运行，互不干扰。防止恶意或无意的非法访问。</li>
<li><strong>共享:</strong>
允许多个进程安全、高效地共享内存中的代码或数据（如共享库）。</li>
<li><strong>效率:</strong>
提高内存利用率，减少碎片，支持多道程序并发执行，提高系统吞吐量。</li>
</ul></li>
<li><strong>逻辑地址空间 (Logical Address Space) vs. 物理地址空间
(Physical Address Space):</strong>
<ul>
<li><strong>逻辑地址（虚拟地址）:</strong>
CPU（或说进程）生成的地址。用户程序看到的地址空间。</li>
<li><strong>物理地址:</strong> 内存硬件单元（Memory Address Register -
MAR）看到的地址，即加载到内存中的实际地址。</li>
<li><strong>内存管理单元 (MMU - Memory Management Unit):</strong>
负责将逻辑地址动态转换为物理地址的硬件设备。</li>
</ul></li>
<li><strong>地址绑定 (Address Binding):</strong>
将程序指令和数据中的地址确定（绑定）到具体物理内存地址的过程。
<ul>
<li><strong>编译时绑定:</strong>
如果编译时就知道程序在内存中的绝对地址，则直接生成绝对代码。要求程序加载到固定位置，缺乏灵活性。</li>
<li><strong>加载时绑定:</strong>
如果编译时不知道加载地址，编译器生成可重定位代码。加载器在加载程序时，根据分配的起始地址进行重定位，将逻辑地址转换为物理地址。程序一旦加载，不能在内存中移动。</li>
<li><strong>运行时绑定 (执行时绑定):</strong>
地址转换延迟到程序运行时才进行。CPU生成的逻辑地址在每次访问内存时由硬件（MMU）动态转换为物理地址。<strong>这是现代操作系统最常用的方式</strong>，允许程序在内存中移动，是虚拟内存的基础。</li>
</ul></li>
<li><strong>重定位 (Relocation):</strong>
将程序中的逻辑地址转换为物理地址的过程。
<ul>
<li><strong>静态重定位:</strong>
在程序加载时由加载器完成。一次性转换，程序加载后不能移动。</li>
<li><strong>动态重定位:</strong>
在程序运行时由硬件(MMU)完成。每次访存都可能需要转换。需要基址寄存器(Base
Register)和限长寄存器(Limit
Register)（用于连续分配）或页表/段表（用于非连续分配）的支持。</li>
</ul></li>
<li><strong>程序的链接与加载 (回顾):</strong>
<ul>
<li><strong>链接:</strong>
将多个目标模块（.o文件）和库函数组合成一个单一的可执行文件的过程。解决外部符号引用，合并代码段、数据段等。</li>
<li><strong>加载:</strong>
将可执行文件从磁盘读入内存，准备运行的过程。涉及空间分配、地址重定位（静态或建立映射关系）。</li>
<li><strong>ELF 文件格式:</strong> Linux
等系统常用的可执行和可链接文件格式，包含文件头、程序头表（描述段）、节头表（描述节）、各种节（如
.text, .data, .bss, .symtab, .rel.text 重定位表）。加载器依赖程序头表将
LOAD 类型的段加载到内存。</li>
</ul></li>
<li><strong>内存保护:</strong>
<ul>
<li>确保进程只能访问分配给自己的内存空间。</li>
<li><strong>界限寄存器 (Base and Limit Registers):</strong>
(用于连续分配)
CPU生成的逻辑地址先与限长寄存器比较，若小于限长，则加上基址寄存器的值得到物理地址；否则地址越界。</li>
<li><strong>保护键 (Protection Keys):</strong> (用于分区)
给每个分区和每个进程赋予一个键值，访问时匹配键值。</li>
<li>(分页/分段中的保护机制后续详述)</li>
</ul></li>
</ul></li>
<li><strong>连续分配 (Contiguous Allocation):</strong>
<ul>
<li><strong>概念:</strong>
为每个进程分配<strong>一块连续</strong>的物理内存区域。</li>
<li><strong>早期方案:</strong>
<ul>
<li><strong>单道程序:</strong> 内存只放OS和一个用户程序。</li>
<li><strong>固定分区 (Fixed Partition / Static Partition):</strong>
内存预先划分为若干固定大小的分区。分区大小可相等或不等。实现简单，但有<strong>内部碎片</strong>。</li>
</ul></li>
<li><strong>动态分区 (Dynamic Partition):</strong>
<ul>
<li>内存不预先划分，根据进程请求的大小动态地从空闲区域中分配。</li>
<li><strong>分配算法:</strong> (当有多个空闲分区满足要求时如何选择)
<ul>
<li><strong>首次适应 (First-Fit):</strong>
从头开始查找，选择第一个足够大的空闲分区。简单快速，但易在低地址产生小碎片。</li>
<li><strong>下次适应 (Next-Fit):</strong>
从上次查找结束的位置开始查找。减少低地址碎片的查找开销，但可能缺乏大空闲块。</li>
<li><strong>最佳适应 (Best-Fit):</strong>
查找所有空闲分区，选择大小与请求最接近（最小且足够大）的那个。试图减少大块被分割，但易产生大量无法利用的极小碎片。</li>
<li><strong>最差适应 (Worst-Fit):</strong>
查找所有空闲分区，选择最大的那个。试图保留更多中小空闲块，但可能导致大块迅速耗尽。</li>
</ul></li>
<li><strong>空闲空间管理:</strong> 如何记录空闲分区？
<ul>
<li><strong>位图 (Bitmap):</strong>
内存划分成小单元，用一位表示单元是否空闲。简单，但查找连续空间可能较慢。</li>
<li><strong>空闲链表 (Free List):</strong>
将所有空闲分区链接起来，记录起始地址和大小。分配和回收时需要维护链表。</li>
</ul></li>
</ul></li>
<li><strong>碎片 (Fragmentation) 问题:</strong>
<ul>
<li><strong>内部碎片 (Internal Fragmentation):</strong>
分配的内存区域<strong>大于</strong>进程实际所需，区域内部未被使用的部分。固定分区和分页都有此问题。</li>
<li><strong>外部碎片 (External Fragmentation):</strong>
内存中存在<strong>足够多</strong>的空闲空间，但它们<strong>不连续</strong>，无法满足较大进程的连续内存请求。动态分区的主要问题。</li>
</ul></li>
<li><strong>紧凑 (Compaction):</strong>
解决外部碎片的方法。通过移动内存中的进程，使所有空闲空间合并成一整块。开销很大，需要动态重定位支持。</li>
<li><strong>伙伴系统 (Buddy System):</strong>
<ul>
<li>介于固定分区和动态分区之间。将可用内存按2的幂次大小进行管理。</li>
<li><strong>分配:</strong>
查找大小合适的空闲块，若没有则分裂更大的块（伙伴块一分为二）直到找到合适大小。</li>
<li><strong>回收:</strong>
回收块时检查其伙伴是否也空闲，若是则合并成更大的块，递归进行。</li>
<li><strong>优点:</strong> 分配回收较快，一定程度上减少外部碎片。</li>
<li><strong>缺点:</strong>
存在内部碎片（因为只能分配2的幂次大小）。Linux 内核中使用。</li>
</ul></li>
<li><strong>覆盖 (Overlay) 与 交换 (Swapping):</strong>
<ul>
<li><strong>覆盖:</strong>
早期用于小内存运行大程序的技术。程序员手动将程序划分为相互覆盖的段，只将需要的段调入内存。对用户不透明。</li>
<li><strong>交换:</strong>
将暂时不运行的整个进程从内存移到外存（磁盘），腾出空间给其他进程。需要时再换回内存。由OS管理。</li>
</ul></li>
</ul></li>
<li><strong>分页 (Paging):</strong>
<ul>
<li><strong>基本思想:</strong>
<ul>
<li>将<strong>物理内存</strong>划分为大小固定的块，称为<strong>页框
(Frame / Page Frame)</strong>。</li>
<li>将<strong>逻辑地址空间</strong>也划分为相同大小的块，称为<strong>页
(Page)</strong>。</li>
<li>通过<strong>页表 (Page Table)</strong> 建立页到页框的映射关系。</li>
<li>进程的页可以<strong>非连续地</strong>存放在物理内存的任何可用页框中。</li>
</ul></li>
<li><strong>机制:</strong>
<ul>
<li><strong>页 (Page):</strong> 逻辑地址空间的基本单位。</li>
<li><strong>页框 (Frame):</strong>
物理内存的基本单位，大小与页相同。</li>
<li><strong>页表 (Page Table):</strong>
每个进程一张页表，存放在内存中。记录该进程每个逻辑页对应的物理页框号。</li>
<li><strong>页表项 (Page Table Entry, PTE):</strong>
页表中的每个条目，包含页框号和其他控制位。</li>
</ul></li>
<li><strong>地址转换过程:</strong>
<ul>
<li>CPU 生成逻辑地址，分为<strong>页号 (p)</strong> 和<strong>页内偏移
(d)</strong>。逻辑地址 = p | d</li>
<li>硬件使用<strong>页号 p</strong>
作为索引在进程的<strong>页表</strong>中查找对应的<strong>页表项
(PTE)</strong>。页表的基地址由<strong>页表基址寄存器 (PTBR)</strong>
指向。</li>
<li>从 PTE 中获取<strong>物理页框号 (f)</strong>。</li>
<li>将<strong>页框号 f</strong> 和<strong>页内偏移 d</strong>
拼接成<strong>物理地址</strong>。物理地址 = f | d</li>
<li><strong>检查:</strong>
地址转换过程中需要检查页号是否越界（与页表长度寄存器 PTLR
比较），以及访问权限（PTE中的保护位）。</li>
</ul></li>
<li><strong>页表项 (PTE) 内容:</strong>
<ul>
<li><strong>页框号 (Frame Number):</strong>
核心内容，指向物理内存块。</li>
<li><strong>有效位/存在位 (Valid/Present Bit):</strong>
标记该逻辑页是否在物理内存中（是否已加载/映射）。用于支持虚拟内存。</li>
<li><strong>保护位 (Protection Bits):</strong>
控制对该页的访问权限，如只读 (Read-Only)、读写 (Read/Write)、可执行
(Execute)。</li>
<li><strong>脏位/修改位 (Dirty/Modified Bit):</strong>
标记该页内容是否被修改过。用于页面换出时判断是否需要写回磁盘。</li>
<li><strong>访问位/引用位 (Accessed/Referenced Bit):</strong>
标记该页是否被访问过。用于页面置换算法（如LRU）。</li>
<li><strong>其他控制位:</strong> 如禁止缓存 (Cache Disabled)、全局页
(Global Page, TLB中不清空) 等。</li>
</ul></li>
<li><strong>页面大小 (Page Size):</strong>
<ul>
<li>由硬件决定，通常是 2 的幂次方（如 4KB, 2MB, 1GB）。</li>
<li><strong>小页面:</strong>
减少内部碎片，但页表更大，页表访问开销可能增加。</li>
<li><strong>大页面:</strong>
减少页表大小和TLB未命中率，但内部碎片可能更严重。</li>
</ul></li>
<li><strong>共享页 (Shared Pages):</strong>
<ul>
<li>允许多个进程的页表项指向<strong>同一个</strong>物理页框。</li>
<li>常用于共享代码（如共享库、编译器）或只读数据。</li>
<li>共享代码必须是<strong>可重入 (Reentrant / Pure Code)</strong>
的，即代码本身在执行过程中不被修改。</li>
<li>写时复制 (Copy-on-Write, CoW) 可用于共享可写页面（如 fork()
时）。</li>
</ul></li>
</ul></li>
<li><strong>页表结构:</strong>
<ul>
<li><strong>问题:</strong>
对于大的逻辑地址空间（如32位或64位），单级页表本身可能非常大，占用大量连续内存。</li>
<li><strong>快表 (Translation Lookaside Buffer, TLB):</strong>
<ul>
<li><strong>定义:</strong> CPU
内部或旁边的一个高速、小的、由硬件管理的<strong>页表缓存</strong>，存储近期访问过的页表项（(页号,
页框号) 对）。</li>
<li><strong>工作流程:</strong> CPU生成逻辑地址 -&gt; 先查TLB:
<ul>
<li><strong>命中 (TLB Hit):</strong>
直接从TLB获取页框号，快速形成物理地址。</li>
<li><strong>未命中 (TLB Miss):</strong>
需要访问内存中的页表，查到PTE后，将其加载到TLB中（可能替换旧条目），再形成物理地址。</li>
</ul></li>
<li><strong>作用:</strong>
大大减少平均内存访问时间，因为大多数访存会命中TLB。</li>
<li><strong>有效访问时间 (EAT):</strong> EAT = HitRate * (TLBAccessTime
+ MemoryAccessTime) + MissRate * (TLBAccessTime + PageTableAccessTime +
MemoryAccessTime)。</li>
<li><strong>ASID (Address-Space Identifier):</strong>
TLB条目中可以包含进程标识符，避免上下文切换时清空整个TLB。</li>
</ul></li>
<li><strong>多级页表 (Hierarchical / Multi-Level Paging):</strong>
<ul>
<li><strong>思想:</strong>
将巨大的单级页表进行<strong>分页</strong>，即把页表本身也存储在页面中。</li>
<li><strong>结构 (以二级为例):</strong> 逻辑地址分为三部分：外层页号
(p1) | 内层页号 (p2) | 页内偏移 (d)。p1 用于索引<strong>外层页表（页目录
Page
Directory）</strong>，找到对应<strong>内层页表</strong>的物理地址（页框号）；p2
用于索引该内层页表，找到数据页的物理页框号 f；最后 f | d
得到物理地址。</li>
<li><strong>优点:</strong>
只有实际使用到的内层页表才需要分配内存，大大节省了存储页表的空间，尤其是在地址空间稀疏使用时。</li>
<li><strong>缺点:</strong>
每次地址转换需要多次访存（二级页表需两次访存查页表，三级需三次...），增加了内存访问延迟（TLB可以缓解此问题）。</li>
</ul></li>
<li><strong>哈希页表 (Hashed Page Table):</strong>
<ul>
<li>常用于处理大于32位的地址空间。</li>
<li>将逻辑页号通过哈希函数映射到哈希表的一个桶 (bucket)。</li>
<li>每个桶包含一个链表，存储 (逻辑页号, 页框号, 指针) 形式的元素。</li>
<li>地址转换时，计算哈希值找到桶，然后遍历链表查找匹配的逻辑页号。</li>
</ul></li>
<li><strong>反向页表 (Inverted Page Table):</strong>
<ul>
<li><strong>思想:</strong>
系统中只有<strong>一张</strong>页表，表的大小与<strong>物理内存页框数</strong>成正比，而不是与所有进程的逻辑地址空间总和成正比。</li>
<li><strong>结构:</strong> 每个页表项对应一个物理页框，存储 (进程ID
(pid), 逻辑页号 (p))。</li>
<li><strong>地址转换:</strong> 给定逻辑地址 (pid, p,
d)，需要在整个反向页表中<strong>搜索</strong> (pid, p) 对，找到其索引
i，则 i 就是物理页框号。搜索通常通过哈希表加速。</li>
<li><strong>优点:</strong>
极大节省了存储页表的空间，尤其是在逻辑地址空间远大于物理内存时。</li>
<li><strong>缺点:</strong>
地址转换需要搜索（即使有哈希表，也比直接索引慢），实现<strong>内存共享困难</strong>（因为一个物理页框只能映射到一个
(pid, p)）。</li>
</ul></li>
</ul></li>
<li><strong>分段 (Segmentation):</strong>
<ul>
<li><strong>基本概念:</strong>
<ul>
<li>将程序的地址空间划分为若干<strong>逻辑意义上</strong>的段
(Segment)，如代码段、数据段、堆栈段等。</li>
<li>段的大小<strong>不定</strong>，由程序的逻辑结构决定。</li>
<li>地址空间是<strong>二维</strong>的：(段号 (s), 段内偏移 (d))。</li>
</ul></li>
<li><strong>机制:</strong>
<ul>
<li><strong>段表 (Segment Table):</strong>
每个进程一张段表，存放在内存中。</li>
<li><strong>段表项 (Segment Descriptor):</strong> 段表中的条目，包含：
<ul>
<li><strong>段基址 (Base Address):</strong>
该段在物理内存中的起始地址。</li>
<li><strong>段限长 (Limit):</strong> 该段的大小/长度。</li>
<li><strong>保护位 (Protection Bits):</strong>
如读/写/执行权限、特权级等。</li>
</ul></li>
<li><strong>段表寄存器:</strong> 存放当前进程段表的基地址和长度。</li>
</ul></li>
<li><strong>地址转换:</strong>
<ul>
<li>CPU生成逻辑地址 (s, d)。</li>
<li>硬件使用段号 s 查找段表，获取段表项。</li>
<li>检查段号 s 是否越界（与段表长度比较）。</li>
<li>检查段内偏移 d 是否越界（d &lt; limit ?）。</li>
<li>检查访问权限。</li>
<li>若检查通过，物理地址 = 段基址 + 段内偏移 d。</li>
</ul></li>
<li><strong>优点:</strong>
<ul>
<li>方便编程、信息共享（以逻辑段为单位共享）、信息保护（以段为单位设置权限）。</li>
<li>支持动态增长（段可以动态改变大小）。</li>
<li>支持动态链接。</li>
</ul></li>
<li><strong>缺点:</strong>
<ul>
<li><strong>外部碎片:</strong>
动态分配和回收不定长的段会导致内存中产生许多不连续的小空闲块。需要使用连续分配的策略（FF,
BF, WF）和可能的紧凑操作。</li>
<li>内存分配复杂。</li>
</ul></li>
<li><strong>分页与分段比较:</strong>
<ul>
<li><strong>用户视图:</strong>
段是用户可见的逻辑单位，页对用户透明。</li>
<li><strong>地址空间:</strong> 段是二维，页是一维。</li>
<li><strong>大小:</strong> 段大小不定，页大小固定。</li>
<li><strong>基本单位:</strong> 段是信息逻辑单位，页是物理单位。</li>
<li><strong>碎片:</strong> 段产生外部碎片，页产生内部碎片。</li>
<li><strong>共享/保护:</strong> 段更方便实现逻辑共享和保护。</li>
</ul></li>
</ul></li>
<li><strong>段页式 (Segmented Paging):</strong>
<ul>
<li><strong>思想:</strong>
结合分段和分页的优点。先将程序按逻辑结构分段，再将每个段分页。</li>
<li><strong>地址结构:</strong> 逻辑地址包含三部分：段号 (s) | 段内页号
(p) | 页内偏移 (d)。</li>
<li><strong>数据结构:</strong>
<ul>
<li>每个进程一张<strong>段表</strong>。段表项包含该段对应的<strong>页表的基地址</strong>和页表长度。</li>
<li>每个<strong>段</strong>一张<strong>页表</strong>。页表项包含物理页框号和控制位。</li>
</ul></li>
<li><strong>地址转换过程:</strong>
<ul>
<li>用段号 s 查段表，得到对应段的页表基地址。</li>
<li>用段内页号 p 查该段的页表，得到物理页框号 f。</li>
<li>物理地址 = f | d。</li>
<li>需要进行段号越界、页号越界和权限检查。</li>
<li><strong>访存次数:</strong>
需要访问三次内存（段表、页表、实际数据），通常使用TLB加速。</li>
</ul></li>
<li><strong>优点:</strong>
兼具分段（逻辑结构清晰、便于共享保护）和分页（无外部碎片、内存分配简单）的优点。</li>
<li><strong>缺点:</strong>
系统开销更大（需要更多硬件支持、地址转换更复杂、需要更多存储空间存放段表和页表）。</li>
<li><strong>X86 实例:</strong>
X86架构（尤其32位保护模式）是段页式管理的典型例子。逻辑地址（由段选择子+偏移组成）-&gt;
通过段描述符（GDT/LDT）和段寄存器 -&gt; 线性地址 -&gt;
通过页目录和页表（CR3寄存器指向页目录）-&gt; 物理地址。Linux 等现代 OS
在 x86-64
上通常采用“扁平模式”，将段基址设为0，限长设为最大，主要依赖分页进行内存管理和保护。</li>
</ul></li>
</ol>
<p><strong>七、虚拟内存</strong></p>
<ol type="1">
<li><strong>核心概念：</strong>
允许逻辑地址空间大于物理地址空间、请求调页（Demand Paging）。</li>
<li><strong>请求调页：</strong> 仅在需要时才加载页面。</li>
<li><strong>缺页处理（Page Fault Handling）：</strong>
<ul>
<li>检测（通过无效PTE）。</li>
<li>操作系统陷阱（trap）处理程序步骤。</li>
<li>需要重新执行导致缺页的指令。</li>
<li>操作系统 vs. 用户进程的角色。</li>
</ul></li>
<li><strong>页面置换算法：</strong>
<ul>
<li>目标：最小化缺页中断次数。</li>
<li>算法：FIFO（先进先出）、LRU（最近最少使用）、OPT（Optimal，理想最优）、二次机会/Clock算法、Aging（LRU近似）、工作集（Working
Set）、WSClock。</li>
<li>算法特性：性能比较（LRU/OPT 通常优于 FIFO）、Belady 异常（FIFO
可能出现）。</li>
</ul></li>
<li><strong>性能问题：</strong>
<ul>
<li>抖动/颠簸（Thrashing）：原因（过度的页面换入换出）、检测、解决方法（降低多道程序度、检查工作集大小）。</li>
<li>局部性原理（时间和空间局部性）是虚拟内存有效工作的基础。</li>
</ul></li>
<li><strong>写时复制（Copy-on-Write, CoW）：</strong> fork()
的优化策略，延迟页面的复制直到有写入操作发生。</li>
</ol>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          <li class="previous">
            <a href="/en/BUAA-OSLab3实验总结/" data-toggle="tooltip" data-placement="top" title="BUAA-OSLab3实验总结">&larr; Previous Post</a>
          </li>
          
          
          <li class="next">
            <a href="/en/BUAA-OO2025第二单元总结/" data-toggle="tooltip" data-placement="top" title="BUAA-OO2025第二单元总结">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      If you like this blog or find it useful for you, you are welcome to comment on it. You are also welcome to share this blog, so that more people can participate in it. If the images used in the blog infringe your copyright, please contact the author to delete them. Thank you !
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->

  <!-- gitalk start -->
  <!-- Docs:https://github.com/gitalk/gitalk/blob/master/readme-cn.md -->

  <div id="gitalk-container"></div>

  
    <!-- <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.js"></script> -->
    <script src="/js/comment/gitalk.js"></script>
  

  <script>
    var gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: '',
      id: 'Sun Apr 20 2025 21:27:36 GMT+0800', // Ensure uniqueness and length less than 50
      distractionFreeMode: false, // Facebook-like distraction free mode
      perPage: ,
      pagerDirection: '',
      createIssueManually: ,
      language: '',
      proxy: ''
    });
    gitalk.render('gitalk-container');

    var gtFolded = () => {
      setTimeout(function () {
        let markdownBody = document.getElementsByClassName("markdown-body");
        let list = Array.from(markdownBody);
        list.forEach(item => {
          if (item.clientHeight > 250) {
            item.classList.add('gt-comment-body-folded');
            item.style.maxHeight = 'px';
            item.title = 'Click to Expand';
            item.onclick = function () {
              item.classList.remove('gt-comment-body-folded');
              item.style.maxHeight = '';
              item.title = '';
              item.onclick = null;
            };
          }
        })
      }, 800);
    }
  </script>

  <!-- gitalk end -->


<!-- 2. gitment comment -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#os%E6%9C%9F%E4%B8%AD%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">OS期中知识点汇总</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#i.-%E5%BC%95%E8%AE%BA%E4%B8%8Eos%E7%BB%93%E6%9E%84"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">I. 引论与OS结构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ii.-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">II. 进程管理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#iii.-%E7%BA%BF%E7%A8%8B-thread"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">III. 线程 (Thread)</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#iv.-cpu-%E8%B0%83%E5%BA%A6"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">IV. CPU 调度</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#v.-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">V. 进程同步</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">FEATURED TAGS</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#OS" title="OS">OS</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
        <hr>
        <h5>FRIENDS</h5>
        <ul class="list-inline">

          
        </ul>
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/S7AM1NA">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          

          

          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          John Doe
          2025
          
            <br>
            <span id="busuanzi_container_site_pv" style="display:none">
              <i class="fa fa-eye"></i>
              <span id="busuanzi_value_site_pv"></span>
            </span>
            <span class="post-meta-divider">|</span>
            <span id="busuanzi_container_site_uv" style="display:none">
              <i class="fa fa-user"></i>
              <span id="busuanzi_value_site_uv"></span>
            </span>
          
          <br>
          Theme by
          <a target="_blank" rel="noopener" href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a target="_blank" rel="noopener" href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script type="text/javascript" src="/js/jquery.min.js"></script>
  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="/js/bootstrap.min.js"></script>
  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="/js/hux-blog.min.js"></script>
  <!-- catalog -->
  <script async="true" type="text/javascript" src="/js/catalog.js"></script>
  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <!-- Scroll start -->
    <script async="async" type="text/javascript" src="/js/scroll.js"></script>
    <!-- Scroll end -->
  

  
    <!-- LangSelect start -->
    <script type="text/javascript" src="/js/langselect.js"></script>
    <!-- LangSelect end -->
  

  
    <!-- Mouseclick -->
    <script type="text/javascript" src="/js/mouseclick.js" content='The first step is as good as half over...,Laugh and grow fat...,Man proposes God disposes...,When all else is lost the future still remains...,Wasting time is robbing oneself...,Sharp tools make good work...,Cease to struggle and you cease to live...,A friend in need is a friend indeed...,Faith can move mountains...' color='#9933CC,#339933,#66CCCC,#FF99CC,#CCCCFF,#6666CC,#663399,#66CC99,#FF0033'></script>
  

  
    <!-- ribbon -->
    <script type="text/javascript" src="/js/ribbonDynamic.js"></script>
  

  
    <!-- Line start -->
    <script async="text/javascript" src="/js/line.js"></script>
    <!-- Line end -->
  






  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("http://s7am1na.github.io/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
		<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="SEARCH..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  
    <script src="/js/ziploader.js"></script>
  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;
            


            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


		
	<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
